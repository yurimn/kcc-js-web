<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Page A</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div class="container">
    This article is intended to provide a high-level overview of the architecture of Flutter, 
    including the core principles and concepts that form its design.
    Flutter is a cross-platform UI toolkit that is designed to allow code reuse across operating systems such as iOS and Android, 
    while also allowing applications to interface directly with underlying platform services. 
    The goal is to enable developers to deliver high-performance apps that feel natural on different platforms, 
    embracing differences where they exist while sharing as much code as possible.
    During development, Flutter apps run in a VM that offers stateful hot reload of changes without needing a full recompile. 
    For release, Flutter apps are compiled directly to machine code, whether Intel x64 or ARM instructions, 
    or to JavaScript if targeting the web. The framework is open source, with a permissive BSD license, 
    and has a thriving ecosystem of third-party packages that supplement the core library functionality.
    
    This overview is divided into a number of sections:

    1. The layer model: The pieces from which Flutter is constructed.
    2. Reactive user interfaces: A core concept for Flutter user interface development.
    3. An introduction to widgets: The fundamental building blocks of Flutter user interfaces.
    4. The rendering process: How Flutter turns UI code into pixels.
    5. An overview of the platform embedders: The code that lets mobile and desktop OSes execute Flutter apps.
    6. Integrating Flutter with other code: Information about different techniques available to Flutter apps.
    7. Support for the web: Concluding remarks about the characteristics of Flutter in a browser environment.
    
    To the underlying operating system, Flutter applications are packaged in the same way as any other native application. 
    A platform-specific embedder provides an entrypoint; coordinates with the underlying operating system for access 
    to services like rendering surfaces, accessibility, and input; and manages the message event loop. 
    The embedder is written in a language that is appropriate for the platform: currently Java and C++ for Android, 
    Objective-C/Objective-C++ for iOS and macOS, and C++ for Windows and Linux. Using the embedder, 
    Flutter code can be integrated into an existing application as a module, or the code might be the entire content of the application. 
    Flutter includes a number of embedders for common target platforms, but other embedders also exist.
    At the core of Flutter is the Flutter engine, which is mostly written in C++ and supports the primitives necessary 
    to support all Flutter applications. The engine is responsible for rasterizing composited scenes whenever a new frame 
    needs to be painted. It provides the low-level implementation of Flutter's core API, 
    including graphics (through Impeller on iOS and coming to Android, and Skia on other platforms) text layout, 
    file and network I/O, accessibility support, plugin architecture, and a Dart runtime and compile toolchain.
    The engine is exposed to the Flutter framework through dart:ui, which wraps the underlying C++ code in Dart classes. 
    This library exposes the lowest-level primitives, such as classes for driving input, graphics, and text rendering subsystems.
    Typically, developers interact with Flutter through the Flutter framework, which provides a modern, 
    reactive framework written in the Dart language. It includes a rich set of platform, layout, and foundational libraries, 
    composed of a series of layers. Working from the bottom to the top, we have:
    Basic foundational classes, and building block services such as animation, painting, 
    and gestures that offer commonly used abstractions over the underlying foundation.
    The rendering layer provides an abstraction for dealing with layout. With this layer, 
    you can build a tree of renderable objects. You can manipulate these objects dynamically, 
    with the tree automatically updating the layout to reflect your changes.
    The widgets layer is a composition abstraction. Each render object in the rendering layer has a corresponding 
    class in the widgets layer. In addition, the widgets layer allows you to define combinations of classes that you can reuse. 
    This is the layer at which the reactive programming model is introduced.
    The Material and Cupertino libraries offer comprehensive sets of controls that use the 
    widget layer's composition primitives to implement the Material or iOS design languages.
    </div>
  </body>
</html>
